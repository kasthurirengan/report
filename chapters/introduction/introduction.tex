The later half of the 20th century had seen a sea change in field of Integrated Circuits. The complexity of design had increased drastically from few hundred to billions of transistors in an integrated circuit. According to Moore's law, transistor count of integrated circuits doubles approximately for every two years. Hardware complexity growth follows Moore's law but verification complexity rises exponential with it\cite{Alok 2010}. The amount of time spent in functional verification is almost 70 percent of the design development time\cite{Alok 2010}.Even after this significant amount of effort, number one cause for silicon re-spin is functional bugs. 
\section{Testing}
It is the process of supplying inputs to a system and finding bugs present in it. The methodology of testing is to develop test cases and run the system with each test case. The main goal of testing to find a bug in the system. Dijkstra stated that testing is a way of showing presence of a bug rather than showing its absence\cite{Dijkstra 1972}. Due to complexity of the hardware design, it's impossible to develop test case for all possible input combinations. Without exhaustive input-output combination in testing, one can never prove the correctness of the system. This led to the idea of using Formal Verification.
\section{Formal Verification}
"Formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification or property, using formal methods of mathematics"\cite{Alok 2010}. Formal verification provides exhaustive exploration of all possible behaviours rather than the traditional approach of testing which explore only few possible behaviours of a system. There are several methods of formal verification available out of which we will be looking into a method of model checking. The main advantages of the method are,
\begin{itemize}
\item The ability to perform verification in a completely automatic manner without any intervention from the user.
\item The result of model checking is always either True or False
\item If the property is failed to satisfy, it always produces a counterexample which provides an insight about the failure of the system
\end{itemize}